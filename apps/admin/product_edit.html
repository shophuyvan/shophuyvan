<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Th√™m / S·ª≠a s·∫£n ph·∫©m</title>
<link rel="stylesheet" href="./styles.css"/>
<script src="./admin_real.js?v=25"></script>
<script src="./sidebar-layout.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<link rel="preconnect" href="https://res.cloudinary.com" crossorigin>
</head>
<body>
<!-- Content will be wrapped by sidebar-layout.js -->

<div class="toolbar">
  <button id="btnTestCloudinary" class="btn">Test Cloudinary</button>
  <label for="zipFile" class="btn primary" style="cursor:pointer">üì¶ Import t·ª´ ZIP</label>
  <input id="zipFile" type="file" accept=".zip" style="display:none"/>
</div>

<div class="grid cols-2">
  <div class="col">
    <label>Ti√™u ƒë·ªÅ</label>
    <input id="title" class="input" placeholder="T√™n s·∫£n ph·∫©m"/>

    <label>M√¥ t·∫£ ng·∫Øn</label>
    <textarea id="shortDesc" class="input" rows="3" placeholder="M√¥ t·∫£ ng·∫Øn..."></textarea>

    <label>M√¥ t·∫£ chi ti·∫øt (HTML)</label>
    <textarea id="desc" class="input" rows="12" placeholder="<h1>Ti√™u ƒë·ªÅ</h1><p>N·ªôi dung...</p>"></textarea>
    <div class="hint">üí° D√πng &lt;h1&gt;, &lt;h2&gt;, &lt;h3&gt; cho c·∫•u tr√∫c r√µ r√†ng</div>

    <div class="grid">
      <div class="row">
        <div class="col">
          <label>SEO Title</label>
          <input id="seoTitle" class="input"/>
          <label>SEO Desc</label>
          <input id="seoDesc" class="input"/>
          <label>Keywords (ph√¢n t√°ch d·∫•u ph·∫©y)</label>
          <div class="toolbar"><button id="pickCat" class="btn">+ Ch·ªçn danh m·ª•c</button></div>
          <input id="keywords" class="input"/>
          <label>Danh m·ª•c (slug)</label>
          <div class="row" style="gap:8px;align-items:center">
            <div class="col"><input id="category" class="input" placeholder="vd: dien-nuoc"/></div>
            <div id="categoryPreview" class="badge" style="display:none"></div>
          </div>
		  <div class="row" style="gap:8px;align-items:center;margin-top:6px;">
  <div class="col">
    <select id="categorySelect" class="input">
      <option value="">-- Ch·ªçn danh m·ª•c --</option>
    </select>
  </div>
  <div>
    <button id="refreshCategories" class="btn">üîÑ C·∫≠p nh·∫≠t danh m·ª•c</button>
  </div>
</div>
<!-- === END CATEGORY DROPDOWN === -->
        </div>
        <div class="col">
          <label>FAQ</label>
          <textarea id="faq" class="input" rows="6" placeholder="H·ªèi: ... | ƒê√°p: ..."></textarea>
          <label>ƒê√°nh gi√° m·∫´u (JSON)</label>
          <textarea id="reviews" class="input" rows="4" placeholder='[{"name":"A","rating":5}]'></textarea>
        </div>
      </div>
    </div>

    <label>Slug</label>
	
    <input id="slug" class="input" placeholder="duong-dan-san-pham"/>
	<div class="hint" style="color:#f59e0b;background:#fffbeb;padding:8px;border-radius:6px;margin-bottom:12px">
  ‚ö†Ô∏è <strong>L∆∞u √Ω:</strong> Gi√° b√°n, gi√° sale, gi√° s·ªâ, t·ªìn kho ph·∫£i nh·∫≠p ·ªü t·ª´ng <strong>Bi·∫øn th·ªÉ</strong> b√™n d∆∞·ªõi
    </div>

    <label>Video (URL)</label>
    <div class="row">
      <div class="col"><input id="video" class="input" placeholder="https://..."/></div>
      <div><input id="videoFile" type="file" accept="video/*"/></div>
      <div><button id="upVideo" class="btn">Upload video</button></div>
    </div>

    <label>H√¨nh ·∫£nh</label>
    <div class="row">
      <div class="col"><input id="imgFile" class="input" type="file" accept="image/*" multiple/></div>
      <div><button class="btn" id="upImg">Upload</button></div>
    </div>
    <div id="imgs" class="list-images"></div>

    <div class="toolbar">
      <button id="saveBtn" class="btn primary">L∆∞u s·∫£n ph·∫©m</button>
      <span class="hint">D·ªØ li·ªáu g·ª≠i t·ªõi /admin/products/upsert</span>
    </div>
  </div>

  <div class="col">
    <div class="toolbar">
      <div class="title">Bi·∫øn th·ªÉ</div>
      <button id="addVar" class="btn">+ Th√™m bi·∫øn th·ªÉ</button>
    </div>
    <div id="variants"></div>
  </div>
</div>

<script>
const CLOUDINARY_CONFIG = {
  cloudName: 'dtemskptf',
  uploadPreset: 'shophuyvan',
  apiKey: '49963168148423'
};

const $ = (s) => document.querySelector(s);
const $$ = (s) => Array.from(document.querySelectorAll(s));
const qs = (k) => new URL(location.href).searchParams.get(k);

Admin.ensureAuth();
let state = { id: qs('id') || '', images: [], variants: [] };

function toast(msg) {
  if (window.Admin && window.Admin.toast) {
    window.Admin.toast(msg);
  } else {
    console.log('TOAST:', msg);
    alert(msg);
  }
}

async function uploadToCloudinary(file, options = {}) {
  const { folder = 'products', resourceType = null } = options;
  
  try {
    const formData = new FormData();
    formData.append('file', file);
    formData.append('upload_preset', CLOUDINARY_CONFIG.uploadPreset);
    formData.append('folder', folder);
    
    const type = resourceType || (file.type.startsWith('video/') ? 'video' : 'image');
    const uploadUrl = `https://api.cloudinary.com/v1_1/${CLOUDINARY_CONFIG.cloudName}/${type}/upload`;
    
    console.log('Uploading:', file.name);
    
    const response = await fetch(uploadUrl, { method: 'POST', body: formData });
    
    if (!response.ok) {
      throw new Error('Upload failed: ' + response.status);
    }
    
    const data = await response.json();
    if (data.error) {
      throw new Error(data.error.message || 'Upload failed');
    }
    
    console.log('Upload success:', data.secure_url);
    return data.secure_url;
    
  } catch (error) {
    console.error('Upload error:', error);
    throw error;
  }
}

async function uploadMultipleToCloudinary(files, onProgress = null) {
  const total = files.length;
  let completed = 0;
  const results = [];
  
  const CHUNK_SIZE = 3;
  for (let i = 0; i < files.length; i += CHUNK_SIZE) {
    const chunk = files.slice(i, i + CHUNK_SIZE);
    const uploads = chunk.map(async (file) => {
      try {
        const url = await uploadToCloudinary(file);
        completed++;
        if (onProgress) onProgress(completed, total);
        return url;
      } catch (e) {
        console.error('Failed:', file.name, e);
        return null;
      }
    });
    
    const chunkResults = await Promise.all(uploads);
    results.push(...chunkResults);
  }
  
  return results.filter(Boolean);
}

function optimizeCloudinaryUrl(url, options = {}) {
  if (!url || !url.includes('cloudinary.com')) return url;
  const { width = 800, quality = 'auto', format = 'auto', crop = 'limit' } = options;
  const transformation = `w_${width},q_${quality},f_${format},c_${crop}`;
  return url.replace('/upload/', `/upload/${transformation}/`);
}

async function doUpload(fileOrFiles) {
  const arr = (Array.isArray(fileOrFiles) ? fileOrFiles : [fileOrFiles]).filter(Boolean);
  
  window.__UPLOAD_NAME_SET__ = window.__UPLOAD_NAME_SET__ || new Set();
  const filtered = [];
  for (const f of arr) {
    const nameKey = (f.name || '').toLowerCase();
    if (nameKey && window.__UPLOAD_NAME_SET__.has(nameKey)) continue;
    if (nameKey) window.__UPLOAD_NAME_SET__.add(nameKey);
    filtered.push(f);
  }
  
  if (!filtered.length) return [];
  
  toast(`ƒêang upload ${filtered.length} file...`);
  
  try {
    const urls = await uploadMultipleToCloudinary(filtered, (completed, total) => {
      console.log(`Progress: ${completed}/${total}`);
    });
    
    if (urls.length > 0) {
      toast(`‚úÖ Upload th√†nh c√¥ng ${urls.length}/${filtered.length} file`);
    }
    return urls;
  } catch (error) {
    toast('‚ùå Upload th·∫•t b·∫°i: ' + error.message);
    return [];
  }
}

function extractTextFromZip(txtContent) {
  const sections = {};
  const lines = txtContent.split('\n');
  let currentKey = null;
  let currentValue = [];
  
  for (const line of lines) {
    const trimmed = line.trim();
    if (trimmed.startsWith('---') && trimmed.endsWith('---')) {
      if (currentKey) {
        sections[currentKey] = currentValue.join('\n').trim();
      }
      currentKey = trimmed.replace(/^---\s*/, '').replace(/\s*---$/, '').trim();
      currentValue = [];
    } else if (currentKey) {
      currentValue.push(line);
    }
  }
  
  if (currentKey) {
    sections[currentKey] = currentValue.join('\n').trim();
  }
  
  return sections;
}

function parseDetailedContent(content) {
  if (!content) return '';
  
  let html = content;
  
  html = html.replace(/^### (.+)$/gm, '<h3>$1</h3>');
  html = html.replace(/^## (.+)$/gm, '<h2>$1</h2>');
  html = html.replace(/^# (.+)$/gm, '<h1>$1</h1>');
  html = html.replace(/^[‚úÖ‚úì-] (.+)$/gm, '<li>$1</li>');
  html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
  
  let inList = false;
  const lines = html.split('\n');
  const processed = [];
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    
    if (line.startsWith('<li>')) {
      if (!inList) {
        processed.push('<ul>');
        inList = true;
      }
      processed.push(line);
    } else {
      if (inList) {
        processed.push('</ul>');
        inList = false;
      }
      
      if (line && !line.startsWith('<h') && !line.startsWith('<ul') && !line.startsWith('</ul')) {
        processed.push(`<p>${line}</p>`);
      } else if (line) {
        processed.push(line);
      }
    }
  }
  
  if (inList) {
    processed.push('</ul>');
  }
  
  return processed.join('\n');
}

async function importFromZip(file) {
  try {
    console.log('Starting ZIP import...');
    toast('üì¶ ƒêang x·ª≠ l√Ω file ZIP...');
    
    const zip = await JSZip.loadAsync(file);
    console.log('ZIP loaded');
    
    let txtContent = '';
    for (const [filename, zipEntry] of Object.entries(zip.files)) {
      if (filename.endsWith('.txt') && !zipEntry.dir) {
        txtContent = await zipEntry.async('text');
        console.log('Found TXT file:', filename);
        break;
      }
    }
    
    if (!txtContent) {
      alert('Kh√¥ng t√¨m th·∫•y file .txt trong ZIP');
      return;
    }
    
    const sections = extractTextFromZip(txtContent);
    console.log('Sections found:', Object.keys(sections));
    
    if (sections['T√äN S·∫¢N PH·∫®M']) {
      $('#title').value = sections['T√äN S·∫¢N PH·∫®M'];
      console.log('Title set:', sections['T√äN S·∫¢N PH·∫®M']);
    }
    
    if (sections['URL SLUG']) {
      $('#slug').value = sections['URL SLUG'];
      console.log('Slug set:', sections['URL SLUG']);
    }
    
    if (sections['M√î T·∫¢ NG·∫ÆN']) {
      $('#shortDesc').value = sections['M√î T·∫¢ NG·∫ÆN'];
      $('#seoDesc').value = sections['M√î T·∫¢ NG·∫ÆN'];
      console.log('Short desc set');
    }
    
    if (sections['TH√îNG TIN CHI TI·∫æT']) {
      const htmlContent = parseDetailedContent(sections['TH√îNG TIN CHI TI·∫æT']);
      $('#desc').value = htmlContent;
      console.log('Detail content set, length:', htmlContent.length);
    }
    
    if (sections['TI√äU ƒê·ªÄ SEO']) {
      $('#seoTitle').value = sections['TI√äU ƒê·ªÄ SEO'];
      console.log('SEO Title set');
    }
    
    const kwSources = [
      sections['T·ª™ KH√ìA TI√äU ƒê·ªÄ'],
      sections['T·ª™ KH√ìA M√î T·∫¢'],
      sections['T·ª™ KH√ìA CH√çNH']
    ].filter(Boolean);
    
    if (kwSources.length > 0) {
      const allKeywords = new Set();
      kwSources.forEach(kw => {
        kw.split(',').forEach(k => allKeywords.add(k.trim()));
      });
      $('#keywords').value = Array.from(allKeywords).join(', ');
      console.log('Keywords set:', allKeywords.size);
    }
    
    if (sections['C√ÇU H·ªéI TH∆Ø·ªúNG G·∫∂P (FAQ)']) {
      const faqText = sections['C√ÇU H·ªéI TH∆Ø·ªúNG G·∫∂P (FAQ)'];
      const faqLines = faqText.split('\n').filter(line => {
        const t = line.trim();
        return t.startsWith('H·ªèi:') || t.startsWith('ƒê√°p:');
      });
      
      const faqPairs = [];
      for (let i = 0; i < faqLines.length; i += 2) {
        if (faqLines[i] && faqLines[i + 1]) {
          faqPairs.push(`${faqLines[i].trim()} | ${faqLines[i + 1].trim()}`);
        }
      }
      $('#faq').value = faqPairs.join('\n');
      console.log('FAQ set:', faqPairs.length, 'pairs');
    }
    
    const imageFiles = [];
    for (const [filename, zipEntry] of Object.entries(zip.files)) {
      if (filename.match(/\.(jpg|jpeg|png|gif|webp)$/i) && !zipEntry.dir) {
        const blob = await zipEntry.async('blob');
        const file = new File([blob], filename, { type: blob.type || 'image/jpeg' });
        imageFiles.push(file);
        console.log('Found image:', filename);
      }
    }
    
    if (imageFiles.length > 0) {
      toast(`üì§ ƒêang upload ${imageFiles.length} h√¨nh ·∫£nh...`);
      const urls = await doUpload(imageFiles);
      if (urls.length) {
        state.images.push(...urls);
        renderImgs();
        console.log('Images uploaded:', urls.length);
      }
    }
    
    toast('‚úÖ Import th√†nh c√¥ng!');
    console.log('Import completed');
    
  } catch (error) {
    console.error('Import error:', error);
    alert('L·ªói khi import ZIP: ' + error.message);
  }
}

function renderImgs() {
  const box = $('#imgs');
  if (!box) return;
  
  box.innerHTML = '';
  (state.images || []).forEach((url, idx) => {
    const wrap = document.createElement('div');
    wrap.className = 'image-card';
    const thumbUrl = optimizeCloudinaryUrl(url, { width: 400, quality: 'auto:eco' });
    wrap.innerHTML = `
      <img src="${thumbUrl}" alt="image-${idx}" loading="lazy" onerror="this.src='${url}'"/>
      <div class="row" style="margin-top:6px">
        <button class="btn" onclick="setCover(${idx})">ƒê·∫∑t cover</button>
        <button class="btn danger" onclick="delImg(${idx})">Xo√°</button>
      </div>`;
    box.appendChild(wrap);
  });
}

window.setCover = (idx) => {
  if (idx > 0) {
    const t = state.images[0];
    state.images[0] = state.images[idx];
    state.images[idx] = t;
    renderImgs();
  }
};

window.delImg = (idx) => {
  state.images.splice(idx, 1);
  renderImgs();
};

function addVar(v = {}) {
  const box = document.createElement('div');
  box.className = 'card';
  const variantImg = v.image ? optimizeCloudinaryUrl(v.image, { width: 200 }) : './no-image.svg';
  
  box.innerHTML = `
    <div class="row">
      <div class="col">
        <label>T√™n bi·∫øn th·ªÉ</label>
        <input class="input" data-f="name" value="${v.name || ''}"/>
      </div>
      <div class="col">
        <label>SKU</label>
        <input class="input" data-f="sku" value="${v.sku || ''}" placeholder="M√£ SKU"/>
      </div>
      <div><button class="btn danger" data-del>Xo√°</button></div>
    </div>
    <div class="row">
      <div class="col"><label>Gi√° b√°n</label><input class="input" type="number" data-f="price" value="${v.price || 0}"/></div>
      <div class="col"><label>Gi√° sale</label><input class="input" type="number" data-f="price_sale" value="${v.price_sale || 0}"/></div>
      <div class="col"><label>üè™ Gi√° s·ªâ</label><input class="input" type="number" data-f="wholesale_price" value="${v.wholesale_price || 0}"/></div>
    </div>
    <div class="row">
      <div class="col"><label>Gi√° nh·∫≠p</label><input class="input" type="number" data-f="cost" value="${v.cost || 0}"/></div>
      <div class="col"><label>C√¢n n·∫∑ng (g)</label><input class="input" type="number" data-f="weight" value="${v.weight || 0}"/></div>
      <div class="col"><label>T·ªìn kho</label><input class="input" type="number" data-f="stock" value="${v.stock || 0}"/></div>
    </div>
    <div class="row">
      <div class="col"><label>·∫¢nh</label><input type="file" data-f="file" accept="image/*"/></div>
      <div><img data-f="thumb" class="thumb" src="${variantImg}"/></div>
      <div><button class="btn" data-up>Upload</button></div>
    </div>`;
  
  const variants = $('#variants');
  if (variants) variants.appendChild(box);
  
  box.querySelector('[data-del]').onclick = () => box.remove();
  box.querySelector('[data-up]').onclick = async () => {
    const f = box.querySelector('[data-f="file"]').files[0];
    if (!f) return alert('Ch·ªçn ·∫£nh');
    try {
      const url = await uploadToCloudinary(f);
      if (url) {
        const optimized = optimizeCloudinaryUrl(url, { width: 200 });
        const thumb = box.querySelector('[data-f="thumb"]');
        thumb.src = optimized;
        thumb.dataset.original = url;
      }
    } catch (e) {
      alert('Upload th·∫•t b·∫°i: ' + e.message);
    }
  };
}

function parseFaq(text) {
  const lines = (text || '').split(/\n+/).map(s => s.trim()).filter(Boolean);
  return lines.map(s => {
    const parts = s.split('|');
    const q = (parts[0] || '').replace(/^H·ªèi:\s*/i, '').trim();
    const a = (parts[1] || '').replace(/^ƒê√°p:\s*/i, '').trim();
    return { q, a };
  });
}

function parseReviews(text) {
  try {
    const j = JSON.parse(text);
    if (Array.isArray(j)) return j;
  } catch (e) {}
  return [];
}

function gramsOf(v) {
  const raw = String(v || '').trim().replace(',', '.');
  if (!raw) return 0;
  let num = Number(raw);
  if (isNaN(num)) return 0;
  if (/[.,]/.test(raw) && num > 0 && num <= 50) return Math.round(num * 1000);
  return Math.round(num);
}

function formatFaqForTextarea(faqArray) {
  if (!Array.isArray(faqArray) || faqArray.length === 0) return '';
  return faqArray.map(item => {
    const q = item.q || item.question || '';
    const a = item.a || item.answer || '';
    return `H·ªèi: ${q} | ƒê√°p: ${a}`;
  }).join('\n');
}
/* === START LOAD CATEGORIES TO SELECT === */
async function loadCategoriesToSelect() {
  const sel = document.getElementById('categorySelect');
  if (!sel) return;

  sel.innerHTML = '<option value="">-- ƒêang t·∫£i danh m·ª•c... --</option>';
  try {
    // L·∫•y danh m·ª•c t·ª´ API (d√πng l·∫°i h√†m c√≥ s·∫µn)
    const cats = await loadCategoriesFlex();
    sel.innerHTML = '<option value="">-- Ch·ªçn danh m·ª•c --</option>' +
      cats.map(c => `<option value="${c.slug}">${c.name}</option>`).join('');

    // N·∫øu form ƒëang s·ª≠a s·∫£n ph·∫©m c√≥ s·∫µn slug danh m·ª•c ‚Üí t·ª± ch·ªçn
    const currentSlug = document.getElementById('category')?.value || '';
    if (currentSlug) sel.value = currentSlug;
  } catch (e) {
    sel.innerHTML = '<option value="">(L·ªói t·∫£i danh m·ª•c)</option>';
    console.error('L·ªói t·∫£i danh m·ª•c:', e);
  }
}

// Khi ch·ªçn dropdown, c·∫≠p nh·∫≠t input slug v√† badge preview
document.addEventListener('change', function(e) {
  if (e.target.id === 'categorySelect') {
    const val = e.target.value;
    const inp = document.getElementById('category');
    const pv = document.getElementById('categoryPreview');
    if (inp) inp.value = val;
    if (pv) { pv.textContent = val; pv.style.display = val ? 'inline-block' : 'none'; }
  }
});

// N√∫t refresh danh m·ª•c
document.addEventListener('click', function(e) {
  if (e.target.id === 'refreshCategories') {
    loadCategoriesToSelect();
  }
});
/* === END LOAD CATEGORIES TO SELECT === */
window.addEventListener('DOMContentLoaded', function() {
  console.log('DOM loaded, initializing sidebar...');
  loadCategoriesToSelect();
  
  // Initialize sidebar layout
  if (window.AdminLayout) {
    const pageTitle = state.id ? 'S·ª≠a s·∫£n ph·∫©m' : 'Th√™m s·∫£n ph·∫©m';
    AdminLayout.init(pageTitle);
  }
  
  console.log('Attaching events...');
  
  const btnTest = document.getElementById('btnTestCloudinary');
  if (btnTest) {
    btnTest.addEventListener('click', async function() {
      console.log('Test button clicked');
      const canvas = document.createElement('canvas');
      canvas.width = 1;
      canvas.height = 1;
      canvas.toBlob(async function(blob) {
        const file = new File([blob], 'test.png', { type: 'image/png' });
        try {
          const url = await uploadToCloudinary(file, { folder: 'test' });
          alert('‚úÖ Cloudinary k·∫øt n·ªëi th√†nh c√¥ng!\n' + url);
        } catch (e) {
          alert('‚ùå Cloudinary l·ªói:\n' + e.message);
        }
      });
    });
    console.log('Test button attached');
  }
  
  const zipInput = document.getElementById('zipFile');
  if (zipInput) {
    zipInput.addEventListener('change', async function(e) {
      console.log('ZIP input changed');
      const file = e.target.files[0];
      if (file) {
        await importFromZip(file);
        e.target.value = '';
      }
    });
    console.log('ZIP input attached');
  }
  
  const btnUpImg = document.getElementById('upImg');
  if (btnUpImg) {
    btnUpImg.addEventListener('click', async function() {
      console.log('Upload image clicked');
      const files = Array.from(document.getElementById('imgFile').files || []);
      if (!files.length) return alert('Ch·ªçn ·∫£nh');
      const urls = await doUpload(files);
      if (urls.length) {
        state.images.push(...urls);
        renderImgs();
      }
    });
    console.log('Upload image button attached');
  }
  
  const btnUpVideo = document.getElementById('upVideo');
  if (btnUpVideo) {
    btnUpVideo.addEventListener('click', async function() {
      console.log('Upload video clicked');
      const f = (document.getElementById('videoFile').files || [])[0];
      if (!f) return alert('Ch·ªçn video');
      
      toast('ƒêang upload video...');
      try {
        const url = await uploadToCloudinary(f, { folder: 'products/videos' });
        if (url) {
          document.getElementById('video').value = url;
          toast('‚úÖ Upload video th√†nh c√¥ng');
        }
      } catch (e) {
        alert('Upload video th·∫•t b·∫°i: ' + e.message);
      }
    });
    console.log('Upload video button attached');
  }
  
  const btnAddVar = document.getElementById('addVar');
  if (btnAddVar) {
    btnAddVar.addEventListener('click', function() {
      console.log('Add variant clicked');
      addVar({});
    });
    console.log('Add variant button attached');
  }
  
   // FIX: Use event delegation for sidebar-layout compatibility
  document.addEventListener('click', async function(e) {
    if (e.target.id !== 'saveBtn' && !e.target.closest('#saveBtn')) return;
    
    console.log('Save button clicked (event delegation)');
    
    // Helper: safe querySelector
    const $safe = (sel) => {
      const el = document.querySelector(sel);
      if (!el) console.warn('Element not found:', sel);
      return el;
    };
    
    const variants = $safe('#variants');
    if (!variants) {
      alert('‚ùå Kh√¥ng t√¨m th·∫•y element variants');
      return;
    }
    
    const vs = Array.from(variants.children || []).map(div => {
      const g = (sel) => div.querySelector(sel);
      const thumb = g('[data-f="thumb"]');
      
      const nameEl = g('[data-f="name"]');
      const skuEl = g('[data-f="sku"]');
      const priceEl = g('[data-f="price"]');
      const priceSaleEl = g('[data-f="price_sale"]');
      const wholesaleEl = g('[data-f="wholesale_price"]');
      const costEl = g('[data-f="cost"]');
      const weightEl = g('[data-f="weight"]');
      const stockEl = g('[data-f="stock"]');
      
      return {
        name: nameEl?.value?.trim() || '',
        sku: skuEl?.value?.trim() || '',
        price: Number(priceEl?.value || 0),
        price_sale: Number(priceSaleEl?.value || 0),
        wholesale_price: Number(wholesaleEl?.value || 0),
        cost: Number(costEl?.value || 0),
        weight: gramsOf(weightEl?.value),
        stock: Number(stockEl?.value || 0),
        image: thumb?.dataset?.original || thumb?.src || ''
      };
    });

    const titleEl = $safe('#title');
    const slugEl = $safe('#slug');
    const shortDescEl = $safe('#shortDesc');
    const descEl = $safe('#desc');
    const seoTitleEl = $safe('#seoTitle');
    const seoDescEl = $safe('#seoDesc');
    const keywordsEl = $safe('#keywords');
    const faqEl = $safe('#faq');
    const reviewsEl = $safe('#reviews');
    const categoryEl = $safe('#category');
    const videoEl = $safe('#video');
    
    if (!titleEl || !slugEl) {
      alert('‚ùå Thi·∫øu th√¥ng tin b·∫Øt bu·ªôc (title/slug)');
      return;
    }

    const payload = {
      id: state.id || undefined,
      title: titleEl.value.trim(),
      slug: slugEl.value.trim(),
      shortDesc: shortDescEl?.value?.trim() || '',
      desc: descEl?.value?.trim() || '',
      seoTitle: seoTitleEl?.value?.trim() || '',
      seoDesc: seoDescEl?.value?.trim() || '',
      keywords: (keywordsEl?.value || '').split(',').map(s => s.trim()).filter(Boolean),
      faq: parseFaq(faqEl?.value || ''),
      reviews: parseReviews(reviewsEl?.value || ''),
      weight: gramsOf(0),
      images: state.images || [],
      category: (categoryEl?.value || '').trim(),
      category_slug: (categoryEl?.value || '').trim(),
      video: videoEl?.value?.trim() || '',
      variants: vs
    };

    console.log('Payload:', payload);

    let r = await Admin.req('/admin/products/upsert', { method: 'POST', body: payload });
    if (!(r && r.ok)) r = await Admin.req('/admin/product', { method: 'POST', body: payload });
    
    if (r && r.ok) {
      toast('‚úÖ ƒê√£ l∆∞u');
      if (!state.id && r.id) state.id = r.id;
      setTimeout(() => { location.href = './products.html?v=' + Date.now(); }, 600);
    } else {
      alert('L∆∞u th·∫•t b·∫°i');
      console.log(r);
    }
  }, true);
  
  console.log('‚úÖ Save button event delegation attached');
  
  const btnPickCat = document.getElementById('pickCat');
  if (btnPickCat) {
    btnPickCat.addEventListener('click', async function() {
      try {
        const cats = await loadCategoriesFlex();
        renderCatPicker(cats || []);
      } catch (e) {
        alert('Kh√¥ng t·∫£i ƒë∆∞·ª£c danh m·ª•c');
      }
    });
    console.log('Pick category button attached');
  }
  
  console.log('All events attached successfully');
});

async function loadCategoriesFlex() {
  const endpoints = ['/public/categories', '/categories', '/api/categories', '/admin/categories'];
  for (const ep of endpoints) {
    try {
      const r = await Admin.req(ep);
      const arr = Array.isArray(r) ? r : Array.isArray(r?.items) ? r.items : null;
      if (arr && arr.length) return arr;
    } catch (e) {}
  }
  return [
    { name: 'Thi·∫øt B·ªã ƒêi·ªán & N∆∞·ªõc', slug: 'dien-nuoc', order: 1 },
    { name: 'Nh√† C·ª≠a ƒê·ªùi S·ªëng', slug: 'nha-cua-doi-song', order: 2 },
    { name: 'Ho√° Ch·∫•t Gia D·ª•ng', slug: 'hoa-chat-gia-dung', order: 3 },
    { name: 'D·ª•ng C·ª• & Thi·∫øt B·ªã Ti·ªán √çch', slug: 'dung-cu-thiet-bi-tien-ich', order: 4 }
  ];
}

function renderCatPicker(items) {
  const ov = document.createElement('div');
  ov.id = '__cat_overlay';
  ov.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,.35);z-index:9999;display:flex;align-items:center;justify-content:center';
  const box = document.createElement('div');
  box.style.cssText = 'width:min(540px,94vw);max-height:82vh;overflow:auto;background:#fff;border:1px solid #d0d7e1;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.2);padding:14px';
  box.innerHTML = '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px"><div style="font-weight:700">Ch·ªçn danh m·ª•c</div><button id="__cat_close" class="btn">ƒê√≥ng</button></div>'
    + '<input id="__cat_search" class="input" placeholder="T√¨m..." style="margin-bottom:8px"/><div id="__cat_list"></div>';
  ov.appendChild(box);
  document.body.appendChild(ov);
  
  const list = box.querySelector('#__cat_list');
  
  function paint(filter) {
    list.innerHTML = '';
    const f = String(filter || '').trim().toLowerCase();
    const arr = (items || []).slice().sort((a, b) => (a.order || 0) - (b.order || 0));
    arr.forEach(c => {
      const name = c.name || c.title || '';
      const slug = c.slug || c.code || '';
      if (f && !(String(name).toLowerCase().includes(f) || String(slug).toLowerCase().includes(f))) return;
      const row = document.createElement('div');
      row.style.cssText = 'display:flex;justify-content:space-between;gap:8px;padding:8px;border-bottom:1px solid #eef2f7;align-items:center';
      row.innerHTML = '<div><div style="font-weight:600">' + name + '</div><div style="font-size:12px;color:#687385">' + slug + '</div></div>'
        + '<button class="btn primary" data-pick="' + slug + '">Ch·ªçn</button>';
      list.appendChild(row);
    });
  }
  
  paint('');
  box.querySelector('#__cat_search').addEventListener('input', (e) => paint(e.target.value));
  box.addEventListener('click', (e) => {
    const btn = e.target && (e.target.closest ? e.target.closest('[data-pick]') : null);
    if (!btn) return;
    const slug = btn.dataset.pick;
    const inp = $('#category');
    if (inp) inp.value = slug;
    const pv = $('#categoryPreview');
    if (pv) {
      pv.textContent = slug;
      pv.style.display = 'inline-block';
    }
    toast('ƒê√£ ch·ªçn: ' + slug);
    ov.remove();
  });
  
  box.querySelector('#__cat_close').onclick = () => ov.remove();
  ov.addEventListener('click', (e) => {
    if (e.target === ov) ov.remove();
  });
}

(async function init() {
  Admin.renderApiBase();
  
  const id = state.id;
  if (!id) return;
  
  const r = await Admin.tryPaths([
    '/admin/products/get?id=' + encodeURIComponent(id),
    '/admin/product?id=' + encodeURIComponent(id)
  ]);
  
  if (r && (r.item || r.data)) {
    const d = r.item || r.data;
    $('#title').value = d.title || d.name || '';
    $('#shortDesc').value = d.shortDesc || '';
    $('#desc').value = d.desc || d.description || '';
    $('#slug').value = d.slug || '';
    $('#seoTitle').value = (d.seo?.title) || d.seoTitle || '';
    $('#seoDesc').value = (d.seo?.desc) || d.seoDesc || '';
    $('#keywords').value = ((d.seo?.keywords) || d.keywords || []).join(', ');
    $('#video').value = d.video || '';
    
    // ‚úÖ FIX: Load FAQ v√†o textarea
    $('#faq').value = formatFaqForTextarea(d.faq || []);
    
    // ‚úÖ FIX: Load Reviews v√†o textarea
    $('#reviews').value = (d.reviews && Array.isArray(d.reviews) && d.reviews.length > 0) 
      ? JSON.stringify(d.reviews, null, 2) 
      : '';
    
    state.images = d.images || [];
    renderImgs();
    
    if ($('#category')) {
      const slugPref = d.category_slug || d.category || d.categoryId || '';
      $('#category').value = slugPref;
      const pv = $('#categoryPreview');
      if (pv && slugPref) {
        pv.textContent = slugPref;
        pv.style.display = 'inline-block';
      }
    }
    
    (d.variants || []).forEach(v => addVar(v));
  }
})();

console.log('‚úÖ Product edit script loaded - FAQ FIX + SIDEBAR APPLIED');
console.log('üì¶ Cloudinary config:', CLOUDINARY_CONFIG.cloudName);
</script>

</body>
</html>