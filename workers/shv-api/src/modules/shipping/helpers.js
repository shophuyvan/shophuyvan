// ===================================================================
// modules/shipping/helpers.js - Shipping Helper Functions
// ===================================================================

import { getJSON, putJSON } from '../../lib/kv.js';

/**
 * L·∫•y SuperAI token (c√≥ th·ªÉ ƒë·ªïi sang ƒë·ªçc t·ª´ env/settings)
 */
export async function superToken(env) {
  // TODO: thay b·∫±ng env.SUPERAI_TOKEN khi b·∫°n ƒë√£ c·∫•u h√¨nh secret
  return "FxXOoDz2qlTN5joDCsBGQFqKmm1UNvOw7YPwkzm5".trim();
}

/**
 * Fetch SuperAI (gi·ªØ nguy√™n c√°ch log/debug hi·ªán t·∫°i)
 */
export async function superFetch(env, path, options = {}) {
  const base = 'https://api.superai.vn'; // d√πng domain ch√≠nh
  const token = await superToken(env);

  console.log('[superFetch] üîë Token retrieved:', token ? `${token.substring(0, 20)}...` : '‚ùå EMPTY');

  const method = (options.method || 'GET').toUpperCase();
  const headers = {
    'Accept': 'application/json',
    'Token': String(token || '').trim(),
    ...options.headers
  };

  console.log('[superFetch] üì§ Headers:', JSON.stringify(headers, null, 2));
  console.log('[superFetch] üåê URL:', base + path);

  const config = { method, headers };

  if (options.body !== undefined && options.body !== null) {
    if (typeof options.body === 'string') {
      config.body = options.body;
    } else {
      config.body = JSON.stringify(options.body);
      config.headers['Content-Type'] = config.headers['Content-Type'] || 'application/json';
    }
  }

  if (config.body) {
    console.log('[superFetch] üì¶ Payload:', String(config.body).substring(0, 500));
  }

  try {
    const response = await fetch(base + path, config);
    const responseText = await response.text();

    console.log('[superFetch] üì• Response status:', response.status);
    console.log('[superFetch] üì• Response body:', (responseText || '').substring(0, 500));

    const contentType = (response.headers.get('content-type') || '').toLowerCase();
    const isJson = contentType.includes('application/json');

    if (isJson) {
      try {
        const json = responseText ? JSON.parse(responseText) : null;
        return json ?? { ok: false, status: response.status, raw: null };
      } catch (err) {
        console.warn('[superFetch] ‚ö†Ô∏è JSON parse failed:', err?.message);
        return { ok: false, status: response.status, raw: responseText || null };
      }
    }

    return { ok: response.ok, status: response.status, raw: responseText || null };
  } catch (e) {
    console.error('[superFetch] ‚ùå Error:', path, e);
    return { ok: false, status: 0, raw: String(e?.message || e) };
  }
}

// ===================================================================
// Carriers: cache danh s√°ch & resolve carrier_code (m√£ s·ªë SuperAI)
// ===================================================================

const NORM = (s) => String(s || '')
  .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
  .toLowerCase().replace(/\s+/g, ' ').trim();

/**
 * L·∫•y danh s√°ch carriers v√† cache 24h v√†o KV
 */
export async function getCarriersList(env) {
  const cacheKey = 'ship:carriers';
  let list = await getJSON(env, cacheKey, null, { ns: 'VANCHUYEN' });
  if (Array.isArray(list) && list.length) return list;

  const res = await superFetch(env, '/v1/platform/carriers/list', { method: 'GET' });
  const arr = Array.isArray(res?.data) ? res.data : [];
  list = arr.map(x => ({
    id: String(x.id ?? ''),
    name: String(x.name ?? ''),
    code: String(x.code ?? ''),   // SuperAI tr·∫£ d·∫°ng chu·ªói s·ªë (VD: '10' cho SPX)
    key: NORM(x.name)
  }));

  if (list.length) {
    await putJSON(env, cacheKey, list, { ns: 'VANCHUYEN', ttl: 86400 }); // 24h
  }
  return list;
}

/**
 * Chu·∫©n ho√° input (t√™n/m√£) ‚Üí tr·∫£ v·ªÅ carrier_code (chu·ªói s·ªë)
 */
export async function resolveCarrierCode(env, raw) {
  const input = String(raw ?? '').trim();
  if (!input) return '';
  // FE/Admin ƒë√£ l∆∞u s·∫µn m√£ s·ªë?
  if (/^\d+$/.test(input)) return input;

  const list = await getCarriersList(env);
  const k = NORM(input);

  // 1) match tuy·ªát ƒë·ªëi
  let hit = list.find(c => c.key === k);
  if (hit?.code) return String(hit.code);

  // 2) alias th∆∞·ªùng g·∫∑p
  const alias = {
    'spx': 'spx express',
    'shopee express': 'spx express',
    'best': 'best express',
    'vtp': 'viettel post',
    'viettelpost': 'viettel post',
    'ghn': 'ghn',
    'giao hang nhanh': 'ghn',
    'ninjavan': 'ninja van'
  };
  const aliasName = alias[k];
  if (aliasName) {
    hit = list.find(c => c.key === NORM(aliasName));
    if (hit?.code) return String(hit.code);
  }

  // 3) match g·∫ßn ƒë√∫ng
  hit = list.find(c => c.key.includes(k) || k.includes(c.key));
  if (hit?.code) return String(hit.code);

  // 4) fallback an to√†n ‚Üí GHN ('2')
  const ghn = list.find(c => c.key === 'ghn');
  return ghn?.code || '2';
}

// ===================================================================
// ƒê·ªãa gi·ªõi h√†nh ch√≠nh & validate
// ===================================================================

/**
 * Tra c·ª©u m√£ province t·ª´ SuperAI API (c√≥ cache)
 */
export async function lookupProvinceCode(env, provinceName) {
  try {
    if (!provinceName || !provinceName.trim()) return null;

    const cacheKey = 'ship:provinces';
    
    // Th·ª≠ l·∫•y t·ª´ cache tr∆∞·ªõc (TTL 7 ng√†y)
    let provinces = await getJSON(env, cacheKey, null, { ns: 'VANCHUYEN' });
    
    // N·∫øu ch∆∞a c√≥ cache, g·ªçi API
    if (!Array.isArray(provinces) || provinces.length === 0) {
      console.log('[Helpers] üîÑ Loading provinces from SuperAI...');
      const data = await superFetch(env, '/v1/platform/areas/province', { method: 'GET' });
      provinces = Array.isArray(data?.data) ? data.data : [];
      
      // L∆∞u cache 7 ng√†y
      if (provinces.length > 0) {
        await putJSON(env, cacheKey, provinces, { ns: 'VANCHUYEN', ttl: 604800 });
        console.log('[Helpers] ‚úÖ Cached', provinces.length, 'provinces');
      }
    }

    // Chu·∫©n h√≥a t√™n ƒë·ªÉ so s√°nh
    const normalize = (s) => String(s || '')
      .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
      .toLowerCase()
      .replace(/^th√†nh ph·ªë\s+/gi, '')
      .replace(/^t·ªânh\s+/gi, '')
      .replace(/\s+/g, ' ')
      .trim();

    const targetName = normalize(provinceName);
    console.log('[Helpers] üîç Looking up province:', targetName);

    // T√¨m province kh·ªõp
    const province = provinces.find(p => {
      const pName = normalize(p.name || '');
      return pName === targetName || pName.includes(targetName) || targetName.includes(pName);
    });

    if (province?.code) {
      console.log('[Helpers] ‚úÖ Found province code:', province.code, 'for', provinceName);
      return String(province.code);
    }

    console.warn('[Helpers] ‚ö†Ô∏è Province not found:', provinceName);
    return null;
  } catch (error) {
    console.error('[Helpers] ‚ùå lookupProvinceCode error:', error);
    return null;
  }
}

/**
 * Tra c·ª©u m√£ district theo t·ªânh + t√™n qu·∫≠n/huy·ªán
 */
export async function lookupDistrictCode(env, provinceCode, districtName) {
  try {
    if (!provinceCode || !districtName) return null;

    console.log(`[Helpers] üîç Looking up district: "${districtName}" in province: ${provinceCode}`);

    const base = 'https://api.superai.vn';
    const token = await superToken(env);
    const url = `${base}/v1/platform/areas/district?province=${provinceCode}`;

    const response = await fetch(url, {
      method: 'GET',
      headers: { 'Accept': 'application/json', 'Token': token }
    });

    if (!response.ok) {
      console.error('[Helpers] District API error:', response.status, await response.text());
      return null;
    }

    const data = await response.json();
    if (!data?.data || !Array.isArray(data.data)) return null;

    const normalizedName = districtName.trim().toLowerCase()
      .replace(/^qu·∫≠n\s+/gi, '')
      .replace(/^huy·ªán\s+/gi, '')
      .replace(/^th·ªã\s+x√£\s+/gi, '')
      .replace(/^th√†nh\s+ph·ªë\s+/gi, '')
      .trim();

    const district = data.data.find(d => {
      const dName = (d.name || '').toLowerCase()
        .replace(/^qu·∫≠n\s+/gi, '')
        .replace(/^huy·ªán\s+/gi, '')
        .replace(/^th·ªã\s+x√£\s+/gi, '')
        .replace(/^th√†nh\s+ph·ªë\s+/gi, '')
        .trim();
      return dName === normalizedName || dName.includes(normalizedName) || normalizedName.includes(dName);
    });

    return district?.code ? String(district.code) : null;
  } catch (error) {
    console.error('[Helpers] lookupDistrictCode error:', error);
    return null;
  }
}

/**
 * Validate/s·ª≠a m√£ district n·∫øu format sai
 */
export async function validateDistrictCode(env, provinceCode, districtCode, districtName) {
  const code = String(districtCode || '').trim();
  if (/^\d{3}$/.test(code)) return code;

  console.warn(`[Helpers] ‚ö†Ô∏è Invalid district_code: "${code}"`);
  if (districtName && districtName.trim()) {
    const lookedUpCode = await lookupDistrictCode(env, provinceCode, districtName);
    if (lookedUpCode) return lookedUpCode;
  }
  return code;
}

/**
 * Tra c·ª©u m√£ commune theo district + t√™n ph∆∞·ªùng/x√£
 */
export async function lookupCommuneCode(env, districtCode, communeName) {
  try {
    if (!districtCode || !communeName) return null;

    const base = 'https://api.superai.vn';
    const token = await superToken(env);
    const url = `${base}/v1/platform/areas/commune?district=${districtCode}`;

    const response = await fetch(url, {
      method: 'GET',
      headers: { 'Accept': 'application/json', 'Token': token }
    });

    if (!response.ok) return null;
    const data = await response.json();
    if (!data?.data || !Array.isArray(data.data)) return null;

    const normalizedName = communeName.trim().toLowerCase()
      .replace(/^ph∆∞·ªùng\s+/gi, '')
      .replace(/^x√£\s+/gi, '')
      .replace(/^th·ªã\s+tr·∫•n\s+/gi, '')
      .trim();

    const commune = data.data.find(c => {
      const cName = (c.name || '').toLowerCase()
        .replace(/^ph∆∞·ªùng\s+/gi, '')
        .replace(/^x√£\s+/gi, '')
        .replace(/^th·ªã\s+tr·∫•n\s+/gi, '')
        .trim();
      return cName === normalizedName || cName.includes(normalizedName) || normalizedName.includes(cName);
    });

    return commune?.code ? String(commune.code) : null;
  } catch (error) {
    console.error('[Helpers] lookupCommuneCode error:', error);
    return null;
  }
}

// ===================================================================
// C√¢n n·∫∑ng t√≠nh ph√≠ (gross/volumetric) - gi·ªØ nguy√™n logic hi·ªán t·∫°i
// ===================================================================

export function chargeableWeightGrams(body = {}, order = {}) {
  // ‚úÖ FIX: ∆Øu ti√™n order.weight_gram (ƒë√£ t√≠nh s·∫µn) tr∆∞·ªõc
  let weight = Number(
    order.weight_gram || 
    order.weight_grams || 
    order.weight || 
    body.weight_gram || 
    body.weight || 
    body.package?.weight_grams || 
    0
  ) || 0;
  
  console.log('[chargeableWeight] Order level weight:', weight, 'g');

  const items = Array.isArray(body.items) ? body.items :
               (Array.isArray(order.items) ? order.items : []);

  if (!weight && items.length) {
    try {
      weight = items.reduce((sum, item) => {
        const w = Number(item.weight_gram || item.weight_grams || item.weight || 0);
        const qty = Number(item.qty || item.quantity || 1);
        const itemTotal = w * qty;
        // ‚úÖ LOG chi ti·∫øt ƒë·ªÉ debug
        console.log('[chargeableWeight] Item:', {
          name: item.name,
          weight_gram: item.weight_gram,
          weight_grams: item.weight_grams,
          weight: item.weight,
          qty,
          itemTotal
        });
        return sum + itemTotal;
      }, 0);
      console.log('[chargeableWeight] Total from items:', weight, 'g');
    } catch (e) {
      console.error('Weight calculation error:', e);
    }
  }

  try {
    const dim = body.package?.dim_cm || body.dim_cm || body.package?.dimensions || {};
    const L = Number(dim.l || dim.length || 0);
    const W = Number(dim.w || dim.width || 0);
    const H = Number(dim.h || dim.height || 0);

    if (L > 0 && W > 0 && H > 0) {
      const volumetric = Math.round((L * W * H) / 5000 * 1000);
      if (volumetric > weight) weight = volumetric;
    }
  } catch (e) {
    console.error('Volumetric calculation error:', e);
  }

  return Math.max(0, Math.round(weight));
}
