/* eslint-disable eqeqeq */
import { AVATAR_DEFAULT_BG_COLOR, MINI_PROGRAM_DOMAIN, BOX_PROPS } from './constants';
import { oldRouteConfig } from './regExp';

export const htmlDecode = (input) => {
  const doc = new DOMParser().parseFromString(input, 'text/html');
  return doc.documentElement.textContent;
};

export const calculateAvatarColor = (name) => {
  if (typeof name !== 'string') {
    return AVATAR_DEFAULT_BG_COLOR[0];
  }
  let sum = 0;
  const length = name.length;
  for (let i = 0; i < length; i += 1) {
    sum += name.charCodeAt(i);
  }
  const colorIndex = sum % AVATAR_DEFAULT_BG_COLOR.length;
  return AVATAR_DEFAULT_BG_COLOR[colorIndex];
};

export const validateSpacingNumber = (space) => {
  const num = parseInt(space, 10);
  if (!isNaN(num) && space.toString() === num.toString() && num >= 0 && num <= 10) {
    return true;
  }
  return false;
};
/**
 *
 * @param {number} num
 * @return {boolean} num is a number or not
 */
export const isNumber = (num) => {
  const n = parseInt(num, 10);
  return !isNaN(num) && num.toString() === n.toString();
};

export const validateSkeletonEffect = (effect) => {
  if (typeof effect !== 'string') return false;
  const effects = {
    fade: true,
    pulse: true,
    wave: true,
  };
  const name = effect.toLowerCase();
  return effects[name];
};

export const getMonthlyDay = (year, month) => {
  let day;
  if (
    month == 1 ||
    month == 3 ||
    month == 5 ||
    month == 7 ||
    month == 8 ||
    month == 10 ||
    month == 12
  ) {
    day = 31;
  } else if (month == 4 || month == 6 || month == 11 || month == 9) {
    day = 30;
  } else if (month == 2) {
    if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {
      day = 29;
    } else {
      day = 28;
    }
  }
  return day;
};

export const getDayOfMonthSuffix = (n) => {
  let num = n;
  if (typeof n === 'string') {
    num = parseInt(n, 10);
  }
  if (!isNaN(num)) {
    if (num >= 11 && num <= 13) {
      return 'th';
    }
    switch (num % 10) {
      case 1:
        return 'st';
      case 2:
        return 'nd';
      case 3:
        return 'rd';
      default:
        return 'th';
    }
  }
  return '';
};

export const getMiniProgramUrl = (appId, path) => {
  if (!appId || typeof appId !== 'string') {
    return '#';
  }
  let paths = [];
  if (path && typeof path === 'string') {
    const pathFormat = path.replace(/\s+/g, '');
    paths = pathFormat.split('/').filter((s) => s !== '');
  }
  let url = `${MINI_PROGRAM_DOMAIN}/${appId}`;
  if (paths.length) {
    url = `${url}/${paths.join('/')}/`;
  }
  return url;
};

export const validateUrl = (url, appRoutes = []) => {
  if (!url || typeof url !== 'string') {
    return false;
  }
  const isAppRoute =
    appRoutes.findIndex((route) => {
      const urlSplit = url.split('/').filter((u) => u !== '' && u.charAt(0) !== '?');
      const routeSplit = route.split('/').filter((r) => r !== '');
      if (urlSplit.length != routeSplit.length) {
        return false;
      }
      for (let i = 0; i < routeSplit.length; i += 1) {
        const dest = urlSplit[i].split('?')[0];
        if (routeSplit[i].charAt(0) !== ':' && routeSplit[i] !== dest) {
          return false;
        }
      }
      return true;
    }) >= 0;
  return isAppRoute;
};

/**
 * @param {dir} string page dir
 */
export const resolvePath = (...arg) => {
  const length = arg.length;
  let splitPaths = [];
  for (let i = 0; i < length; i += 1) {
    if (typeof arg[i] === 'string') {
      const pathFormat = arg[i].replace(/\s+/g, '');
      const paths = pathFormat.split('/').filter((s) => s !== '');
      splitPaths = [...splitPaths, ...paths];
    }
  }
  let fileName;
  let dir = [];
  const dirLength = splitPaths.length;
  if (dirLength > 0) {
    fileName = splitPaths[dirLength - 1];
    dir = dirLength > 1 ? splitPaths.slice(0, dirLength - 1) : [];
  }
  return { dir, fileName };
};

/**
 * @param {string} Page Directory
 * @returns {object} {path: route path, fileDir: file name directory}
 */
export const toRoutePath = (dir) => {
  if (typeof dir !== 'string') {
    throw Error('Dir must be a string');
  }
  const pathFormat = dir.replace(/\s+/g, '');
  const paths = pathFormat.split('/').filter((s) => s !== '');
  for (let i = 0; i < paths.length; i += 1) {
    if (paths[i].charAt(0) === '[') {
      const formated = paths[i].replace('[', ':').replace(']', '');

      paths[i] = formated;
    }
  }
  return { path: `/${paths.join('/')}/`, fileDir: paths.join('/') };
};

/**
 * @param {dir} string page dir
 */
export const standardizePageDir = (dir) => {
  if (typeof dir !== 'string') {
    throw Error('Dir must be a string');
  }

  const hasPagesDir = oldRouteConfig.test(dir);

  if (hasPagesDir) {
    return dir.replace(oldRouteConfig, '');
  }
  return dir;
};
/**
 *
 * @param {any} value
 * @param {string} prop
 * @return {boolean} num is valid props
 */

export const isValidBoxProps = (value, prop) => {
  if (!value || !prop) return false;
  if (!BOX_PROPS[prop]) return false;
  return BOX_PROPS[prop].find((val) => val === value);
};

/**
 * @return {boolean} if localStorage is available
 */
export const checkLocalStorage = () => {
  try {
    localStorage.setItem('test', 'test');
    localStorage.removeItem('test');
    return true;
  } catch (e) {
    return false;
  }
};
